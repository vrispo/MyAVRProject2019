/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>

#include "Networking.s3d"
#include "player.s3d"
#include "Level.s3d"

#define MAX_PLAYERS 4

#define CONNECT_REQ_PDU 0
#define CONNECT_RESP_PDU 1
#define DISCONNECT_REQ_PDU 2
#define ACK 3

#define OK 1
#define ERR -1

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;

// TODO: put your global variables here
var my_id;
var broadcast_address;
var net_channel;
var connected = false;

var aplayer = array(MAX_PLAYERS);
var online_player = array(MAX_PLAYERS);
var my_index = 0;

var my_ip;
var server_ip;

var level_obj_l;
var my_level;

/* Camera globals */
var CamPos = [2.0, 3.0, 20.0]; 	// camera position

/* Light globals */
var Light0;
var PosL = [16.0, 100.0, 16.0];	// default light position


/* Function declarations */
function CameraMoveMouse();
function DrawGrid(col, size);

function OnDownload(){
	// TODO: download your resources here
	// E.g.: FileDownload("resource.ext");
	FileDownload("XVRResources.zip");
}

function OnInit(params){
	/* initialize camera */
	CameraGetCurrent().SetPosition(CamPos);

	/* initialize light */
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetDiffuse(1, 1, 1);
	Light0.Enable();	

	// TODO: put your initialization code here	
	my_level = level();
	my_level.init("level1.txt");
	level_obj_l = my_level.__Get("level_obj");
	
	for(var i=0 ; i < MAX_PLAYERS ; i++){
		aplayer[i] = player();
		online_player[i] = false;
	}
	
	var CurDir = getcurrentdir();
	SetCurrentDir(".");
	
	GLOBAL var TestDLL = CVmExternDLL( "../UtilityDll/Release/UtilityDll.dll" );
	TestDLL.__AddFunction (C_PCHAR, "get_IPaddress");
	TestDLL.__AddFunction(C_INT, "open_idprog");
	Outputln("\n");
	Outputln(TestDLL.open_idprog());
	my_id = fileread("userid.txt");
	outputln("id = " + my_id);
	
	my_ip = TestDLL.get_IPaddress();
	Outputln("\n");
	Outputln("IP:" + my_ip);
	var ip_elem[4];
	ip_elem = split(my_ip + "", ".");
	broadcast_address = ip_elem[0] + "." + ip_elem[1] + "." + ip_elem[2] + ".255";
	outputln("broadcast = " + broadcast_address);
	
	SetCurrentDir(CurDir);
	
	net_channel= NetCreateChannel(CLIENT_PORT, "0.0.0.0", VR_NO_BLOCKING);
	
	/* Send request in broadcast to find server ip */
	var PDU = array(3);
	PDU[0] = CONNECT_REQ_PDU;
	PDU[1] = my_id;
	PDU[2] = my_ip;
	mysend(broadcast_address, PDU);
	outputln("sended REQ_CONNECT");
	
	/* wait for the server response */
	var address1 = "................";
	var received_data = NetVarReceiveFrom(net_channel, &address1);
	var recv = false;
	
	var old_time = getTime();//returns time in milliseconds
	do{		
		outputln("in the do while");
		var current_time = getTime();
    	if(current_time-old_time>1000){
    		outputln("timeout: try send REQ_CONNECT again to:" + broadcast_address);
    		mysend(broadcast_address, PDU);
    		outputln("timeout: send REQ_CONNECT again");
    		old_time = getTime();
		} 
		received_data = NetVarReceiveFrom(net_channel, &address1);
		outputln("after received data");	
		if(received_data != null){
			outputln("received something");
			if(received_data[0] == CONNECT_RESP_PDU){
				outputln("received CONNECT_RESP");
				var resp = received_data[1];
				if(resp != ERR){
					connected = true;
					server_ip = received_data[2];
					my_index = received_data[3];
					aplayer[my_index].init([1, 0, 0], received_data[4], level_obj_l);
					online_player[my_index] = true;
				}
				else{
					connected = false;
					server_ip = received_data[2];
					aplayer[my_index].init([1, 0, 0], [2, 0, 2], level_obj_l);				
				}
				for(var i = 0 ; i < MAX_PLAYERS ; i++){
					if(i != my_index)
						aplayer[i].init([0, 1, 0], [30, 0, 30], level_obj_l);
				}
				recv = true;				
			}			
		}							
    } while (!recv);
	/* send ack */
	PDU = array(2);
	PDU[0] = ACK;
	PDU[1] = OK;
	mysend(server_ip, PDU); 
	outputln("sended ACK");   	
}

function OnFrame(){
	/* manage camera */
	CameraMoveMouse();

	SceneBegin();

	// TODO: put your drawing code here
	aplayer[my_index].update();
	
	my_level.draw();
	for(var i=0 ; i < MAX_PLAYERS ; i++){
		if((online_player[i] == true) && (i != my_index)){
			aplayer[i].draw();
		}		
	}
	aplayer[my_index].draw();
	
	if(!connected){
		ConsoleColor([255, 0, 0, 1]);
		ConsoleText(0.5, 0.5, "You are not online!");		
	}
	else{
		ConsoleColor([0, 255, 0, 1]);
		ConsoleText(0.02, 0.96, "You (" + my_id + ") are online!");		
	}	
	SceneEnd();
}



function DownloadReady(RequestID){
	// TODO
}



function OnTimer(){
	// TODO:
	var address1 = "................";
	var received_data = NetVarReceiveFrom(net_channel,&address1);
	
	if(received_data != NULL){
		if(received_data[0] == CONNECT_RESP_PDU){
			/* the ack must been lost I send ack again*/
			var PDU = array(2);
			PDU[0] = ACK;
			PDU[1] = OK;
			mysend(server_ip, PDU);
		}
	}
	
}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}


function OnExit(){
	// TODO: put your cleanup code here
	/* Send request in broadcast to find server ip */
	var recv = false;
	
	outputln("disconnession...");
	var PDU = array(4);
	PDU[0] = DISCONNECT_REQ_PDU;
	PDU[1] = my_ip;
	PDU[2] = my_id;
	PDU[3] = my_index;
	mysend(server_ip, PDU);
	
	/*aspetto l'ack */
	var address1 = "................";
	var received_data;
	
	var old_time = getTime();//returns time in milliseconds
	do{		
		var current_time = getTime();
    	if(current_time-old_time>1000){
    		mysend(server_ip, PDU);
    		old_time = getTime();
		} 
		received_data = NetVarReceiveFrom(net_channel, &address1);	
		if(received_data != null)
			if(received_data[0] == ACK)
				recv = true;;				
    }while(!recv);
    outputln("disconnected!");
}



// Camera manager (using mouse)
function CameraMoveMouse(){	
	CameraMoveMouse_MBL_LC();

}



function DrawGrid(col, size){
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
