/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>

#include "Networking.s3d"
#include "player.s3d"
#include "Level.s3d"

#define MAX_PLAYERS 4

#define CONNECT_REQ_PDU 0
#define CONNECT_RESP_PDU 1
#define DISCONNECT_REQ_PDU 2
//#define ACK 3 definita in player
#define POSITION_UPDATE_PDU 4
#define ENEMY_POSITION_PDU 5
#define ENEMY_DISCONNECTION_PDU 6
#define PING 7
//#define POSITION_BULLET_PDU 8 definita in player
#define DELETE_BULLET_PDU 9

#define OK 1
#define ERR -1

#define CAMERA_OFFSET [0.0, 1.2, 0.0]

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;

// TODO: put your global variables here
var my_id;
var broadcast_address;
//var net_channel; definita in player
var connected = false;

var aplayer = array(MAX_PLAYERS);
var aplayer_color = {[1,0,0],[0,1,0],[0,0,1],[1,1,0]};
var online_player = array(MAX_PLAYERS);
//var my_index = 0; definita in player
var is_enemy_updated = array(MAX_PLAYERS);

var my_ip;
//var server_ip; definita in player

var level_obj_l;
var my_level;

/* Camera globals */
var CamPos = [2.0, 3.0, 20.0]; 	// camera position

/* Light globals */
var Light0;
var PosL = [16.0, 20, 16.0];	// default light position
var Light1;
var PosL1 = [0.0, 20, 0.0];	
var Light2;
var PosL2 = [0.0, 20, 32.0];	
var Light3;
var PosL3 = [32.0, 20, 0.0];	
var Light4;
var PosL4 = [32.0, 20, 32.0];	

/* Function declarations */
function CameraMove();
function DrawGrid(col, size);

function OnDownload(){
	// TODO: download your resources here
	// E.g.: FileDownload("resource.ext");
	FileDownload("XVRResources.zip");
}

var failed_attempts = 0;

function OnInit(params){
	/* initialize camera */
	//CameraGetCurrent().SetPosition(CamPos);

	/* initialize light */
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetDiffuse(1, 1, 1);
	Light0.Enable();
	Light1 = CVmLight();
	Light1.SetPosition(PosL1);
	Light1.SetDiffuse(1, 1, 1);
	Light1.Enable();
	Light2 = CVmLight();
	Light2.SetPosition(PosL2);
	Light2.SetDiffuse(1, 1, 1);
	Light2.Enable();
	Light3 = CVmLight();
	Light3.SetPosition(PosL3);
	Light3.SetDiffuse(1, 1, 1);
	Light3.Enable();
	Light4 = CVmLight();
	Light4.SetPosition(PosL4);
	Light4.SetDiffuse(1, 1, 1);
	Light4.Enable();	

	// TODO: put your initialization code here	
	my_level = level();
	my_level.init("level1.txt");
	level_obj_l = my_level.__Get("level_obj");
	
	for(var i=0 ; i < MAX_PLAYERS ; i++){
		aplayer[i] = player();
		online_player[i] = false;
		is_enemy_updated[i] = false;
	}
	
	var CurDir = getcurrentdir();
	SetCurrentDir(".");
	
	GLOBAL var TestDLL = CVmExternDLL( "../UtilityDll/Release/UtilityDll.dll" );
	TestDLL.__AddFunction (C_PCHAR, "get_IPaddress");
	TestDLL.__AddFunction(C_INT, "open_idprog");
	Outputln("\n");
	Outputln(TestDLL.open_idprog());
	my_id = fileread("userid.txt");
	outputln("id = " + my_id);
	
	my_ip = TestDLL.get_IPaddress();
	Outputln("\n");
	Outputln("IP:" + my_ip);
	var ip_elem[4];
	ip_elem = split(my_ip + "", ".");
	broadcast_address = ip_elem[0] + "." + ip_elem[1] + "." + ip_elem[2] + ".255";
	outputln("broadcast = " + broadcast_address);
	
	SetCurrentDir(CurDir);
	
	net_channel= NetCreateChannel(CLIENT_PORT, "0.0.0.0", VR_NO_BLOCKING);
	
	/* Send request in broadcast to find server ip */
	var PDU = array(3);
	PDU[0] = CONNECT_REQ_PDU;
	PDU[1] = my_id;
	PDU[2] = my_ip;
	mysend(broadcast_address, PDU);
	outputln("sended REQ_CONNECT");
	
	/* wait for the server response */
	var address1 = "................";
	var received_data = NetVarReceiveFrom(net_channel, &address1);
	var recv = false;
	
	var old_time = getTime();//returns time in milliseconds
	do{		
		var current_time = getTime();
    	if(current_time-old_time>1000){
    		outputln("timeout: try send REQ_CONNECT again to:" + broadcast_address);
    		mysend(broadcast_address, PDU);
    		outputln("timeout: send REQ_CONNECT again");
    		old_time = getTime();
    		failed_attempts++;
		} 
		received_data = NetVarReceiveFrom(net_channel, &address1);
		if(received_data != null){
			if(received_data[0] == CONNECT_RESP_PDU){
				outputln("received CONNECT_RESP");
				var resp = received_data[1];
				if(resp != ERR){
					connected = true;
					server_ip = received_data[2];
					my_index = received_data[3];
					aplayer[my_index].init(aplayer_color[my_index], received_data[4], level_obj_l);
					online_player[my_index] = true;
				}
				else{
					connected = false;
					server_ip = received_data[2];
					aplayer[my_index].init(aplayer_color[my_index], [2, 0, 2], level_obj_l);				
				}
				for(var i = 0 ; i < MAX_PLAYERS ; i++){
					if(i != my_index)
						aplayer[i].init(aplayer_color[i], [-1, -1, -1], level_obj_l);
				}
				recv = true;				
			}			
		}
		if (failed_attempts >= 10){
			var Window = CVmWebBrowser();
			Window.Quit();
		}						
    } while (!recv);

	/* send ack */
	PDU = array(2);
	PDU[0] = ACK;
	PDU[1] = OK;
	mysend(server_ip, PDU);
	
	/* Set onTimer 10 times faster than on frame */
	SetTimeStep(1);
}

var old_updatetime = 0;

function OnFrame(){
	/* manage camera */

	SceneBegin();

	// TODO: put your drawing code here
	aplayer[my_index].update(server_ip);
	
	if(connected){
		/* send my position to the server */
		var current_updatetime = getTime();//returns time in milliseconds
	    if(current_updatetime - old_updatetime > 50){
	    	old_updatetime = current_updatetime;
	    	
			var PDU = array(8);
			PDU[0] = POSITION_UPDATE_PDU;
			PDU[1] = my_ip;
			PDU[2] = my_index;
			PDU[3] = aplayer[my_index].__get("position");
			PDU[4] = aplayer[my_index].__get("move");
			PDU[5] = aplayer[my_index].__get("current_frame");
			PDU[6] = aplayer[my_index].__get("angle_xz");
			PDU[7] = aplayer[my_index].__get("railgun_equipped");
			mysend(server_ip, PDU);
			
			/*aspetto l'ack */
			var address1 = "................";
			var received_data;
			var recv = false;
			
			var old_time = getTime();//returns time in milliseconds
			do{		
				var current_time = getTime();
		    	if(current_time-old_time > 1000){
		    		mysend(server_ip, PDU);
		    		old_time = getTime();
				} 
				received_data = NetVarReceiveFrom(net_channel, &address1);	
				if(received_data != null)
					if(received_data[0] == ACK){
						recv = true;
						if(received_data[1] == ERR)
							connected = false;
					}								
		    }while(!recv);
	    }		
	}

	
	
	my_level.draw();
	
	if(connected){
		/* if there is some enemy active I draw it */
		for(var i=0 ; i < MAX_PLAYERS ; i++){
			if((online_player[i]) && (i != my_index)){
				if (!is_enemy_updated[i])
					aplayer[i].enemyInterpolate();
				else
					is_enemy_updated[i] = false;
				aplayer[i].draw();
			}
		}		
	}
	
	aplayer[my_index].fp_draw();
	
	CameraMove();
	
	if(!connected){
		ConsoleColor([255, 0, 0, 1]);
		ConsoleText(0.5, 0.5, "You are not online!");		
	}
	else{
		ConsoleColor([0, 255, 0, 1]);
		ConsoleText(0.02, 0.96, "You (" + my_id + ") are online!");		
	}	
	SceneEnd();
}



function DownloadReady(RequestID){
	// TODO
}



function OnTimer(){
	// TODO:
	
	var address1 = "................";
	var received_data = NetVarReceiveFrom(net_channel,&address1);
	
	if((received_data != NULL) && connected){
		if(received_data[0] == CONNECT_RESP_PDU){
			/* the ack must been lost I send ack again*/
			var PDU = array(2);
			PDU[0] = ACK;
			PDU[1] = OK;
			mysend(server_ip, PDU);
		}
		if(received_data[0] == ENEMY_POSITION_PDU){
			var enemy_index = received_data[1];
			var enemy_position = received_data[2];
			var enemy_move = received_data[3];
			var enemy_frame = received_data[4];
			var enemy_angle = received_data[5];
			var enemy_gun = received_data[6];
			
			is_enemy_updated[enemy_index] = true;
			
			online_player[enemy_index] = true;
			aplayer[enemy_index].enemyUpdate(enemy_position, enemy_move, enemy_frame, enemy_angle, enemy_gun);
			
			/* send the ack
			var PDU = array(2);
			PDU[0] = ACK;
			PDU[1] = OK;
			mysend(server_ip, PDU);
			outputln("ACCO il server");*/
		}
		if(received_data[0] == ENEMY_DISCONNECTION_PDU){
			var enemy_index = received_data[1];
			online_player[enemy_index] = false;
			outputln("enemy " + str(enemy_index) + " disconnected");
			
			/* send the ack
			var PDU = array(2);
			PDU[0] = ACK;
			PDU[1] = OK;
			mysend(server_ip, PDU);*/
		}
		if(received_data[0] == PING){
			var PDU = array(2);
			PDU[0] = PING;
			PDU[1] = my_index;
			mysend(server_ip, PDU);			
		}
		if(received_data[0] == POSITION_BULLET_PDU){
			aplayer[my_index].insertBullet(received_data[1], received_data[2], received_data[3], received_data[4], received_data[5], received_data[6]);			
		}
		if(received_data[0] == DELETE_BULLET_PDU){		
			aplayer[my_index].deleteBullet(received_data[1], received_data[2]);
		}
	}
	
}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}


function OnExit(){
	// TODO: put your cleanup code here
	/* Send request in broadcast to find server ip */
	var recv = false;
	
	outputln("disconnession...");
	var PDU = array(4);
	PDU[0] = DISCONNECT_REQ_PDU;
	PDU[1] = my_ip;
	PDU[2] = my_id;
	PDU[3] = my_index;
	mysend(server_ip, PDU);
	
	/*aspetto l'ack */
	var address1 = "................";
	var received_data;
	
	var old_time = getTime();//returns time in milliseconds
	do{		
		var current_time = getTime();
    	if(current_time-old_time>1000){
    		mysend(server_ip, PDU);
    		old_time = getTime();
		} 
		received_data = NetVarReceiveFrom(net_channel, &address1);	
		if(received_data != null)
			if(received_data[0] == ACK)
				recv = true;;				
    }while(!recv);
    outputln("disconnected!");
}



// Camera manager (using mouse)
function CameraMove(){  
  //CameraMoveMouse_MBL_LC();
  CameraGetCurrent().SetPosition(aplayer[my_index].__get("position") + CAMERA_OFFSET);
  var temp_angle = aplayer[my_index].__get("angle_xz");
  CameraGetCurrent().SetDirection([sin(temp_angle), 0, cos(temp_angle)]);
}



function DrawGrid(col, size){
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
