#include "Bullet.s3d"

#define SWAT_START_WALK 16
#define SWAT_END_WALK 48
#define COLLISION_SCALE 0.80, 1.6, 0.80
#define FRONT_STEP 0.1
#define SIDE_STEP 0.05
#define FRAME_STEP 1.0
#define JUMP_HEIGHT 1.5
#define Y_OFFSET [0.0, 0.1, 0.0]

var shoot_fx;
var step_fx;
var start_fx;
var level_obj_array;

class Player{
	var lower_mesh;
	var upper_mesh;
	var collision_box;
	var weapon_mesh;
	var obj;
	var collision_obj;
	var old_position;
	var position;
	var angle;
	var strafe;
	var left_strafe;
	var right_strafe;
	var direction;
	var jump_step;
	var jump_target;
	var current_frame;
	var run;
	var is_jumping;
	var is_ascending;
	var my_bullet;
	var has_shot;
	var color;
	
	init(col, pos, level_obj_l);
	draw();
	isColliding();
	setPosition(pos);
	getYCollision();
	setRotation(angle);
	update();
	wasd();
	jump();
	updateY();
};

function Player::init(col, pos, level_obj_l){
	level_obj_array = level_obj_l;
	
	lower_mesh = CVmNewMesh("swat_lower.aam");
	var sf1 = lower_mesh.normalize(1);
	upper_mesh = CVmNewMesh("swat_upper.aam");
	upper_mesh.scale(sf1);
	collision_box = CVmNewMesh(VRP_CYLINDER);
	collision_box.scale(COLLISION_SCALE);
	var collision_box_transparent = CVmMaterial();
	collision_box_transparent.transparency = 0.0; //Set the collision box transparent
	collision_box.setMaterial(collision_box_transparent);
	weapon_mesh = CVmNewMesh("rocketl.aam");
	weapon_mesh.scale(sf1);
	
	var lower_obj = CVmObj(lower_mesh);
	var upper_obj = CVmObj(upper_mesh);
	var weapon_obj = CVmObj(weapon_mesh);
	collision_obj = CVmObj(collision_box);
	obj = CVmObj();
	obj.addchild(upper_obj);
	obj.addchild(lower_obj);
	obj.addchild(weapon_obj);
	
	angle = 0.0;
	position = pos;	
	old_position = position;
	direction = [0.0, 0.0 , 1.0];
	current_frame = SWAT_START_WALK;
	run = 1.0;
	color = col;
	jump_target = pos[1];
	is_jumping = false;
	is_ascending = false;
	has_shot = false;
	
	obj.modulatematerials(color);	

	shoot_fx = CVmVRawAV("shoot.wav");
	step_fx = CVmVRawAV("step.wav");
	start_fx = CVmVRawAV("Start.wav");
	
	start_fx.play(); //So it doesn't block
}

function Player::draw(){
	obj.draw(VR_FRAMENUMBER, current_frame);
	collision_obj.draw();
	if (has_shot)
		my_bullet.draw();
}

function Player::isColliding(){
	foreach (var t in level_obj_array)
		if (collision_obj.isCollidingBBox(t))
			return true;
	return false;
}

function Player::wasd(){
	var strafe = 1;	
	if (keyPressed("d")){
		strafe = 2;
		position -= (right_strafe * SIDE_STEP);
	} else if (keyPressed("a")){
		strafe = 2;
		position -= (left_strafe * SIDE_STEP);
	}
	// No else if because of diagonal movement	
	if (keyPressed("w")){
		position += (direction * (FRONT_STEP / strafe) * run);
		current_frame += FRAME_STEP;
		if (current_frame == SWAT_END_WALK){
			current_frame = SWAT_START_WALK + 1;
			step_fx.play();
		}		
	} else if (keyPressed("s")){
		position -= (direction * (FRONT_STEP / strafe));
		current_frame -= FRAME_STEP;
		if(current_frame == SWAT_START_WALK){
			current_frame = SWAT_END_WALK - 1;
			step_fx.play();
		}
	} else if (strafe == 2){ // Manage animation for strafing only
		current_frame += FRAME_STEP;
		if (current_frame == SWAT_END_WALK){
			current_frame = SWAT_START_WALK + 1;
			step_fx.play();
		}
	}
	
	if (!getYCollision()) {
		updateY();
	}
}

function Player::jump(){
	is_jumping = true;
	is_ascending = true;
	jump_target = position.y + JUMP_HEIGHT;
}

function Player::updateY(){
	if (position.y < jump_target && is_ascending){
		position += ([0.0, 0.1, 0.0]);
	} else {
		is_ascending = false;
		if (position.y > 0.0){			
			position -= ([0.0, 0.1, 0.0]);
		} else {
			position.y = 0.0;
			jump_target = 0.0;
			is_jumping = false;
		}
	}
}

function Player::setPosition(pos){
	obj.setPosition(pos);
	collision_obj.setPosition(pos);
}

function Player::getYCollision(){
	var check = false;
	
	collision_obj.setPosition(position - Y_OFFSET);
	
	foreach (var t in level_obj_array)
		check = check || collision_obj.isCollidingBBox(t);
		
	collision_obj.setPosition(position + Y_OFFSET);
	
	return check;
}

function Player::setRotation(angle){
	obj.setRotation(angle * 180.0 / PI, 0, 1, 0);
}

function Player::update(){
	var i = int(position.z);
	var j = int(position.x);
	var k = int(position.y);
	var collision_check = false;
	
	foreach (var t in level_obj_array)
		collision_check = collision_check || collision_obj.isCollidingBBox(t);
	if (!collision_check)
		old_position = position;
	
	if (keyPressed(VK_SHIFT)){
		run = 1.5;
	} else {
		run = 1.0;
	}
	
	if (keyPressed("e"))
		angle -= 0.01;
	else if (keyPressed("q"))
		angle += 0.01;
	
	direction = [sin(angle), 0, cos(angle)];
	
	var angle_r = angle + (PI / 2);
	var angle_l = angle - (PI / 2);
	right_strafe = [sin(angle_r), 0.0, cos(angle_r)];
	left_strafe = [sin(angle_l), 0.0, cos(angle_l)];
	
	wasd();
	if (keyPressed(VK_SPACE) && !is_jumping)
		jump();
	if (is_jumping)
		updateY();
		
	setRotation(angle);
	setPosition(position);
	
	foreach (var t in level_obj_array)
		collision_check = collision_check || collision_obj.isCollidingBBox(t);
	if (collision_check){
		if (is_jumping){
			is_jumping = false;
			jump_target = 0.0;
			old_position[1] = floor(old_position[1]) + 0.001;
		}
		position = old_position;
		setPosition(position);
	}
	
	trace(position, jump_target);
}