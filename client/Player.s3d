#include "Bullet.s3d"

#define SWAT_START_WALK 16
#define SWAT_END_WALK 48
#define COLLISION_SCALE 0.90, 1.6, 0.90
#define Z_COLLISION_OFF 0.0
#define X_COLLISION_OFF 0.0

class Player{
	var lower_mesh;
	var upper_mesh;
	var collision_box;
	var weapon_mesh;
	var obj;
	var collision_obj;
	var position;
	var angle;
	var left_strafe;
	var right_strafe;
	var direction;
	var step;
	var side_step;
	var frame_step;
	var current_frame;
	var run;
	var my_bullet;
	var has_shot;
	var color;
	var shoot_fx;
	var step_fx;
	
	init(col);
	draw();
	setPosition(pos);
	setRotation(angle);
	update(level_obj_l);
};

function Player::init(col){
	color = col;
	lower_mesh = CVmNewMesh("swat_lower.aam");
	var sf1 = lower_mesh.normalize(1);
	upper_mesh = CVmNewMesh("swat_upper.aam");
	upper_mesh.scale(sf1);
	collision_box = CVmNewMesh(VRP_CYLINDER);
	collision_box.scale(COLLISION_SCALE);
	var collision_box_transparent = CVmMaterial();
	collision_box_transparent.transparency = 0.0; //Set the collision box transparent
	collision_box.setMaterial(collision_box_transparent);
	weapon_mesh = CVmNewMesh("rocketl.aam");
	weapon_mesh.scale(sf1);
	
	var lower_obj = CVmObj(lower_mesh);
	var upper_obj = CVmObj(upper_mesh);
	var weapon_obj = CVmObj(weapon_mesh);
	collision_obj = CVmObj(collision_box);
	obj = CVmObj();
	obj.addchild(upper_obj);
	obj.addchild(lower_obj);
	obj.addchild(weapon_obj);
	collision_obj.setpivotpoint(Z_COLLISION_OFF, 0, X_COLLISION_OFF);
	
	obj.modulatematerials(color);	
	
	angle = 0;
	direction = [0,0,1];
	step = 0.1;	
	side_step = 0.05;
	frame_step = 1.0;
	current_frame = SWAT_START_WALK;
	run = 1;
	
	has_shot = false;
	shoot_fx = CVmVRawAV("shoot.wav");
	step_fx = CVmVRawAV("step.wav");
	step_fx.play(); //So it doesn't block
}

function Player::draw(){
	obj.draw(VR_FRAMENUMBER, current_frame);
	collision_obj.draw();
	if (has_shot)
		my_bullet.draw();
}

function Player::setPosition(pos){
	position = pos;
	obj.setPosition(position);
	collision_obj.setPosition(position + [-Z_COLLISION_OFF, 0, -X_COLLISION_OFF]);
}

function Player::setRotation(angle){
	obj.setRotation(angle * 180.0 / PI, 0, 1, 0);
}

function Player::update(level_obj_l){
	var old_position = position;
	
	if (keyPressed(VK_SHIFT)){
		run = 1.5;
	} else {
		run = 1;
	}
	
	if (keyPressed("e"))
		angle -= 0.01;
	else if (keyPressed("q"))
		angle += 0.01;
	
	direction = [sin(angle), 0, cos(angle)];
	
	var angle_r = angle-(PI/2);
	var angle_l = angle+(PI/2);
	right_strafe = [sin(angle_r), 0, cos(angle_r)];
	left_strafe = [sin(angle_l), 0, cos(angle_l)];
	
	var strafe = 1;	
	if (keyPressed("d")){
		strafe = 2;
		position -= (right_strafe * side_step);
	} else if (keyPressed("a")){
		strafe = 2;
		position -= (left_strafe * side_step);
	}
	// No else if because of diagonal movement	
	if (keyPressed("w")){
		position += (direction * (step / strafe) * run);
		current_frame += frame_step;
		if (current_frame == SWAT_END_WALK){
			current_frame = SWAT_START_WALK + 1;
			step_fx.play();
		}		
	} else if (keyPressed("s")){
		position -= (direction * (step / strafe));
		current_frame -= frame_step;
		if(current_frame == SWAT_START_WALK){
			current_frame = SWAT_END_WALK - 1;
			step_fx.play();
		}
	} else if (strafe == 2){ // Manage animation for strafing only
		current_frame += frame_step;
		if (current_frame == SWAT_END_WALK){
			current_frame = SWAT_START_WALK + 1;
			step_fx.play();
		}
	}
	
		
	setRotation(angle);
	setPosition(position);
	
	var i = int(position.z);
	var j = int(position.x);
	var k = int(position.y);
	var collision_check = false;
	foreach (var t in level_obj_l)
		collision_check = collision_check || collision_obj.isCollidingBBox(t);
	if (collision_check)
		position = old_position;
		
	if (keyPressed(VK_SPACE) && !has_shot){
		my_bullet = bullet();
		my_bullet.init(position, direction);
		shoot_fx.play();
		has_shot = true;
	}
	if (has_shot)
		my_bullet.update();
}